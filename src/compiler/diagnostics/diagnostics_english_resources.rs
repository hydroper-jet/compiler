use lazy_static::lazy_static;
use maplit::hashmap;
use crate::ns::*;

lazy_static! {
    pub static ref DATA: HashMap<i32, String> = hashmap! {
        // DiagnosticKind::K.id() => "".into(),
        DiagnosticKind::UnexpectedOrInvalidToken.id() => "Unexpected or invalid token".into(),
        DiagnosticKind::UnexpectedEnd.id() => "Unexpected end of program".into(),
        DiagnosticKind::UnallowedNumericSuffix.id() => "Unallowed numeric suffix".into(),
        DiagnosticKind::UnallowedLineBreak.id() => "Unallowed line break".into(),
        DiagnosticKind::Expected.id() => "Expected {1} before {2}".into(),
        DiagnosticKind::ExpectedIdentifier.id() => "Expected identifier before {1}".into(),
        DiagnosticKind::ExpectedExpression.id() => "Expected expression before {1}".into(),
        DiagnosticKind::ExpectedXmlName.id() => "Expected XML name before {1}".into(),
        DiagnosticKind::ExpectedXmlAttributeValue.id() => "Expected XML attribute value before {1}".into(),
        DiagnosticKind::IllegalNullishCoalescingLeftOperand.id() => "Illegal nullish ooalescing left operand".into(),
        DiagnosticKind::WrongParameterPosition.id() => "Wrong parameter position".into(),
        DiagnosticKind::DuplicateRestParameter.id() => "Duplicate rest parameter".into(),
        DiagnosticKind::NotAllowedHere.id() => "{1} not allowed here".into(),
        DiagnosticKind::MalformedRestParameter.id() => "Malformed rest parameter".into(),
        DiagnosticKind::IllegalForInInitializer.id() => "Illegal 'for..in' initializer".into(),
        DiagnosticKind::MultipleForInBindings.id() => "Multiple 'for..in' bindings are not allowed".into(),
        DiagnosticKind::UndefinedLabel.id() => "Undefined label '{1}'".into(),
        DiagnosticKind::IllegalContinue.id() => "Illegal continue statement".into(),
        DiagnosticKind::IllegalBreak.id() => "Illegal break statement".into(),
        DiagnosticKind::ExpressionMustNotFollowLineBreak.id() => "Expression must not follow line break".into(),
        DiagnosticKind::TokenMustNotFollowLineBreak.id() => "Token must not follow line break".into(),
        DiagnosticKind::ExpectedStringLiteral.id() => "Expected string literal before {1}".into(),
        DiagnosticKind::DuplicateAttribute.id() => "Duplicate attribute".into(),
        DiagnosticKind::DuplicateVisibility.id() => "Duplicate visibility".into(),
        DiagnosticKind::ExpectedDirectiveKeyword.id() => "Expected directive keyword".into(),
        DiagnosticKind::UnallowedAttribute.id() => "Unallowed attribute".into(),
        DiagnosticKind::UseDirectiveMustContainPublic.id() => "Use directive must contain the 'public' attribute".into(),
        DiagnosticKind::MalformedEnumMember.id() => "Malformed enumeration member".into(),
        DiagnosticKind::FunctionMayNotBeGenerator.id() => "Function may not be generator".into(),
        DiagnosticKind::FunctionMayNotBeAsynchronous.id() => "Function may not be asynchronous".into(),
        DiagnosticKind::FunctionMustNotContainBody.id() => "Function must not contain body".into(),
        DiagnosticKind::FunctionMustContainBody.id() => "Function must contain body".into(),
        DiagnosticKind::FunctionMustNotContainAnnotations.id() => "Function must not contain annotations".into(),
        DiagnosticKind::NestedClassesNotAllowed.id() => "Nested classes are not allowed".into(),
        DiagnosticKind::DirectiveNotAllowedInInterface.id() => "Directive not allowed in interface".into(),
        DiagnosticKind::FailedParsingJetDocTag.id() => "Failed parsing contents of JetDoc tag: '@{1}'".into(),
        DiagnosticKind::UnrecognizedJetDocTag.id() => "Unrecognized JetDoc tag: '@{1}'".into(),
        DiagnosticKind::UnrecognizedProxy.id() => "Unrecognized proxy: '{1}'".into(),
        DiagnosticKind::EnumMembersMustBeConst.id() => "Enumeration members must be 'const'".into(),
        DiagnosticKind::ConstructorMustNotSpecifyResultType.id() => "Constructor must not specify result type".into(),
        DiagnosticKind::IncompatibleTypes.id() => "Incompatible types: expected '{1}', got '{2}'".into(),
        DiagnosticKind::ReferenceIsWriteOnly.id() => "Reference is write-only".into(),
        DiagnosticKind::ReferenceIsReadOnly.id() => "Reference is read-only".into(),
        DiagnosticKind::ReferenceIsNotDeletable.id() => "Reference is not deletable".into(),
        DiagnosticKind::AmbiguousReference.id() => "Ambiguous reference to '{1}'".into(),
        DiagnosticKind::AccessingPropertyOfVoidBase.id() => "Accessing property of base with static type 'void'".into(),
        DiagnosticKind::AccessingPropertyOfNullableBase.id() => "Accessing property of nullable base with static type '{1}'".into(),
        DiagnosticKind::InaccessibleProperty.id() => "Access of inaccessible property '{1}'".into(),
        DiagnosticKind::TypeParameterizedPropertyMustBeArgumented.id() => "Type parameterized property must be argumented".into(),
        DiagnosticKind::UnrecognizedEmbedExpressionField.id() => "Unrecognized embed expression field".into(),
        DiagnosticKind::MustResolveToType.id() => "Expression must resolve to type".into(),
        DiagnosticKind::EmbedSourceOrTypeNotSpecified.id() => "Embed source or type not specified".into(),
        DiagnosticKind::EmbedUnsupportedType.id() => "Embed expression unsupported data type: '{1}'".into(),
        DiagnosticKind::FailedLoadingEmbeddedFile.id() => "Failed loading embedded file: '{1}'".into(),
        DiagnosticKind::FailedParsingNumericLiteral.id() => "Failed parsing numeric literal".into(),
        DiagnosticKind::StringLiteralMustBeASingleCharacter.id() => "String literal must be a single character".into(),
        DiagnosticKind::EnumerationHasNoMember.id() => "Enumeration '{1}' has no member '{2}'".into(),
        DiagnosticKind::UnrecognizedMetadataSyntax.id() => "Unrecognized meta-data syntax".into(),
        DiagnosticKind::FailedLoadingMetadataFile.id() => "Failed loading meta-data file at '{1}'".into(),
        DiagnosticKind::IllegalThisReference.id() => "Illegal this reference".into(),
        DiagnosticKind::CannotUseTypeInRest.id() => "Cannot use type in rest: '{1}'".into(),
        DiagnosticKind::ArrayLiteralMustNotContainElision.id() => "Array literal must not contain elision".into(),
        DiagnosticKind::ArrayLiteralMustNotContainRest.id() => "Array literal must not contain rest".into(),
        DiagnosticKind::ArrayLiteralExceedingTupleElements.id() => "Array literal exceeding tuple elements: '{1}'".into(),
        DiagnosticKind::InitializerUnsupportedType.id() => "Initializer unsupported type: '{1}'".into(),
        DiagnosticKind::UndefinedProperty.id() => "Access of undefined property '{1}'".into(),
        DiagnosticKind::IncompatibleFieldKey.id() => "Incompatible field key".into(),
        DiagnosticKind::MissingPropertyInLiteral.id() => "Missing property in literal: '{1}'".into(),
        // DiagnosticKind::K.id() => "".into(),
    };
}